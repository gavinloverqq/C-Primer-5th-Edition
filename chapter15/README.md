1. 遵循基类的接口。
2. 类静态成员的初始化，练习7.58 
3. 虚函数默认实参, 通过基类的指针或者引用调用函数，则使用基类中定义的默认实参。即使运行的是派生类中的函数版本也是如此。参考输出5
4. 回避虚函数机制，使用域作用符（参考练习15.11、15.13）
5. 派生访问控制符更像是修饰父类的修饰符，将父类所有成员的修饰符等级比访问控制符高则全部变成访问控制符所修饰的。例如控制符为private，则父类成员全部变private继承下来；控制符为public，则原样继承下来。
6. protected成员在派生类中到底是什么样的存在？怎么访问，怎样的权限？？？为什么基类成员不能访问，派生类成员却能访问
7. 派生类向基类转换的可访问性（书P544），解释如下：
---
派生类向基类转换本质上是用访问控制符来控制的。

D继承B，

public：（B对D完全可见）D的用户可以完成D转化为B、当前D的成员函数或友元能完成D到B的转换（private控制的是当前类的子类以及用户的权限，考虑一个类class A{private：int i;}这个i在A里都是可见的，这个private控制的是A的子类以及用户的权限）、D的派生类或友元能完成D到B的转换

protect：（B对D以及D的子类可见）用户不能完成转换、当前D的成员函数或友元能完成D到B的转换、D的派生类或友元能完成D到B的转换（protect能访问）

private：（B对D不可见）用户不能完成转换、当前D的成员函数或友元能完成D到B的转换、D的派生类或友元不能完成D到B的转换（private生效了）